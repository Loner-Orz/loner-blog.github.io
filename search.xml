<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>springboot3-核心原理</title>
      <link href="/2023/07/02/springboot3-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
      <url>/2023/07/02/springboot3-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-事件和监听器"><a href="#1-事件和监听器" class="headerlink" title="1. 事件和监听器"></a>1. 事件和监听器</h1><h2 id="1-生命周期监听"><a href="#1-生命周期监听" class="headerlink" title="1. 生命周期监听"></a>1. 生命周期监听</h2><p>场景：监听<strong>应用</strong>的<strong>生命周期</strong></p><h3 id="1-监听器-SpringApplicationRunListener"><a href="#1-监听器-SpringApplicationRunListener" class="headerlink" title="1. 监听器-SpringApplicationRunListener"></a>1. 监听器-SpringApplicationRunListener</h3><ol><li><p>自定义<code>SpringApplicationRunListener</code>来<strong>监听事件</strong>；</p></li><li><ol><li>编写<code>SpringApplicationRunListener</code> <strong>实现类</strong></li><li>在 <code>META-INF/spring.factories</code> 中配置 <code>org.springframework.boot.SpringApplicationRunListener=自己的Listener</code>，还可以指定一个<strong>有参构造器</strong>，接受两个参数<code>(SpringApplication application, String[] args)</code></li><li>springboot 在<code>spring-boot.jar</code>中配置了默认的 Listener，如下</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681829576654-d5e4b889-6fcf-4e65-91f1-8de8c78e98f1.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_23%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Listener先要从 META-INF/spring.factories 读到</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1、引导： 利用 BootstrapContext 引导整个项目启动</span></span><br><span class="line"><span class="comment"> *      starting：              应用开始，SpringApplication的run方法一调用，只要有了 BootstrapContext 就执行</span></span><br><span class="line"><span class="comment"> *      environmentPrepared：   环境准备好（把启动参数等绑定到环境变量中），但是ioc还没有创建；【调一次】</span></span><br><span class="line"><span class="comment"> * 2、启动：</span></span><br><span class="line"><span class="comment"> *      contextPrepared：       ioc容器创建并准备好，但是sources（主配置类）没加载。并关闭引导上下文；组件都没创建  【调一次】</span></span><br><span class="line"><span class="comment"> *      contextLoaded：         ioc容器加载。主配置类加载进去了。但是ioc容器还没刷新（我们的bean没创建）。</span></span><br><span class="line"><span class="comment"> *      =======截止以前，ioc容器里面还没造bean呢=======</span></span><br><span class="line"><span class="comment"> *      started：               ioc容器刷新了（所有bean造好了），但是 runner 没调用。</span></span><br><span class="line"><span class="comment"> *      ready:                  ioc容器刷新了（所有bean造好了），所有 runner 调用完了。</span></span><br><span class="line"><span class="comment"> * 3、运行</span></span><br><span class="line"><span class="comment"> *     以前步骤都正确执行，代表容器running。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="2-生命周期全流程"><a href="#2-生命周期全流程" class="headerlink" title="2. 生命周期全流程"></a>2. 生命周期全流程</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1682322663331-25a89875-7ce3-40ae-9be7-9ea752fbab20.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_31%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" alt="img"></p><h2 id="2-事件触发时机"><a href="#2-事件触发时机" class="headerlink" title="2. 事件触发时机"></a>2. 事件触发时机</h2><h3 id="1-各种回调监听器"><a href="#1-各种回调监听器" class="headerlink" title="1. 各种回调监听器"></a>1. 各种回调监听器</h3><ul><li><p><code>BootstrapRegistryInitializer</code>：    <strong>感知特定阶段：</strong>感知<strong>引导初始化</strong></p></li><li><ul><li><code>META-INF/spring.factories</code></li><li>创建引导上下文<code>bootstrapContext</code>的时候触发。</li><li>application.<code>addBootstrapRegistryInitializer</code>();</li><li>场景：<code>进行密钥校对授权。</code></li></ul></li><li><p>ApplicationContextInitializer：   <strong>感知特定阶段：</strong> 感知ioc容器初始化</p></li><li><ul><li><code>META-INF/spring.factories</code></li><li>application.addInitializers();</li></ul></li><li><p><strong>ApplicationListener：    感知全阶段：基于事件机制，感知事件。 一旦到了哪个阶段可以做别的事</strong></p></li><li><ul><li><code>@Bean</code>或<code>@EventListener</code>： <code>事件驱动</code></li><li><code>SpringApplication.addListeners(…)</code>或 <code>SpringApplicationBuilder.listeners(…)</code></li><li><code>META-INF/spring.factories</code></li></ul></li><li><p><strong>SpringApplicationRunListener：       感知全阶段生命周期 + 各种阶段都能自定义操作； 功能更完善。</strong></p></li><li><ul><li><code>META-INF/spring.factories</code></li></ul></li><li><p><strong>ApplicationRunner:          感知特定阶段：感知应用就绪Ready。卡死应用，就不会就绪</strong></p></li><li><ul><li><code>@Bean</code></li></ul></li><li><p><strong>CommandLineRunner：   感知特定阶段：感知应用就绪Ready。卡死应用，就不会就绪</strong></p></li><li><ul><li><code>@Bean</code></li></ul></li></ul><p>最佳实战：</p><ul><li>如果项目启动前做事： <code>BootstrapRegistryInitializer</code> 和 <code>ApplicationContextInitializer</code></li><li>如果想要在项目启动完成后做事：<code>**ApplicationRunner**</code><strong>和</strong> <code>**CommandLineRunner**</code></li><li><strong>如果要干涉生命周期做事：</strong><code>**SpringApplicationRunListener**</code></li><li><strong>如果想要用事件机制：</strong><code>**ApplicationListener**</code></li></ul><h3 id="2-完整触发流程"><a href="#2-完整触发流程" class="headerlink" title="2. 完整触发流程"></a>2. 完整触发流程</h3><p><code>**9大事件**</code>触发顺序&amp;时机</p><ol><li><code>ApplicationStartingEvent</code>：应用启动但未做任何事情, 除过注册listeners and initializers.</li><li><code>ApplicationEnvironmentPreparedEvent</code>：  Environment 准备好，但context 未创建.</li><li><code>ApplicationContextInitializedEvent</code>: ApplicationContext 准备好，ApplicationContextInitializers 调用，但是任何bean未加载</li><li><code>ApplicationPreparedEvent</code>： 容器刷新之前，bean定义信息加载</li><li><code>ApplicationStartedEvent</code>： 容器刷新完成， runner未调用</li></ol><p>=========以下就开始插入了<strong>探针机制</strong>============</p><ol><li><code>AvailabilityChangeEvent</code>： <code>LivenessState.CORRECT</code>应用存活； <strong>存活探针</strong></li><li><code>ApplicationReadyEvent</code>: 任何runner被调用</li><li><code>AvailabilityChangeEvent</code>：<code>ReadinessState.ACCEPTING_TRAFFIC</code><strong>就绪探针</strong>，可以接请求</li><li><code>ApplicationFailedEvent</code>：启动出错</li></ol><p><img src="https://i.postimg.cc/66mjT458/image.png" alt="img"></p><p>应用事件发送顺序如下：</p><p><img src="https://i.postimg.cc/fRrmfmpd/image.png" alt="img"></p><p>感知应用是否<strong>存活</strong>了：可能植物状态，虽然活着但是不能处理请求。</p><p>应用是否<strong>就绪</strong>了：能响应请求，说明确实活的比较好。</p><h3 id="3-SpringBoot-事件驱动开发"><a href="#3-SpringBoot-事件驱动开发" class="headerlink" title="3. SpringBoot 事件驱动开发"></a>3. SpringBoot 事件驱动开发</h3><p><strong>应用启动过程生命周期事件感知（9大事件）</strong>、<strong>应用运行中事件感知（无数种）</strong>。</p><ul><li><strong>事件发布</strong>：<code>ApplicationEventPublisherAware</code>或<code>注入：ApplicationEventMulticaster</code></li><li><strong>事件监听</strong>：<code>组件 + @EventListener</code></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1682327167479-8f634931-f8ca-48fb-9566-c914f1795ff2.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_33%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1682341921101-aa095a84-00cc-4815-b675-f4ed81cecf3b.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_22%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" alt="img"></p><p>事件发布者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventPublisher</span> <span class="keyword">implements</span> <span class="title class_">ApplicationEventPublisherAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 底层发送事件用的组件，SpringBoot会通过ApplicationEventPublisherAware接口自动注入给我们</span></span><br><span class="line"><span class="comment">     * 事件是广播出去的。所有监听这个事件的监听器都可以收到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有事件都可以发</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">//调用底层API发送事件</span></span><br><span class="line">        applicationEventPublisher.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会被自动调用，把真正发事件的底层组组件给我们注入进来</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationEventPublisher event publisher to be used by this object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件订阅者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CouponService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Order(1)</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(LoginSuccessEvent loginSuccessEvent)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===== CouponService ====感知到事件&quot;</span>+loginSuccessEvent);</span><br><span class="line">        <span class="type">UserEntity</span> <span class="variable">source</span> <span class="operator">=</span> (UserEntity) loginSuccessEvent.getSource();</span><br><span class="line">        sendCoupon(source.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendCoupon</span><span class="params">(String username)</span>&#123;</span><br><span class="line">        System.out.println(username + <span class="string">&quot; 随机得到了一张优惠券&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-自动配置原理"><a href="#2-自动配置原理" class="headerlink" title="2. 自动配置原理"></a>2. 自动配置原理</h1><h2 id="1-入门理解"><a href="#1-入门理解" class="headerlink" title="1. 入门理解"></a>1. 入门理解</h2><p>应用关注的<strong>三大核心</strong>：<strong>场景</strong>、<strong>配置</strong>、<strong>组件</strong></p><h3 id="1-自动配置流程"><a href="#1-自动配置流程" class="headerlink" title="1. 自动配置流程"></a>1. 自动配置流程</h3><p><img src="https://i.postimg.cc/0QTqYWd4/image.png" alt="img"></p><ol><li>导入<code>starter</code></li><li>依赖导入<code>autoconfigure</code></li><li>寻找类路径下 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>文件</li><li><p>启动，加载所有 <code>自动配置类</code> <code>xxxAutoConfiguration</code></p></li><li><ol><li>给容器中配置<strong>功能</strong><code>组件</code></li><li><code>组件参数</code>绑定到 <code>属性类</code>中。<code>xxxProperties</code></li><li><code>属性类</code>和<code>配置文件</code>前缀项绑定</li><li><code>@Contional派生的条件注解</code>进行判断<strong>是否组件生效</strong></li></ol></li><li><p>效果：</p></li><li><ol><li>修改配置文件，修改底层参数</li><li>所有场景自动配置好直接使用</li><li>可以注入SpringBoot配置好的组件随时使用</li></ol></li></ol><h3 id="2-SPI机制"><a href="#2-SPI机制" class="headerlink" title="2. SPI机制"></a>2. SPI机制</h3><ul><li><strong>Java中的SPI（Service Provider Interface）是一种软件设计模式，用于**</strong>在应用程序中动态地发现和加载组件<strong><strong>。</strong></strong>SPI的思想**是，定义一个接口或抽象类，然后通过在classpath中定义实现该接口的类来实现对组件的动态发现和加载。</li><li>SPI的主要目的是解决在应用程序中使用可插拔组件的问题。例如，一个应用程序可能需要使用不同的日志框架或数据库连接池，但是这些组件的选择可能取决于运行时的条件。通过使用SPI，应用程序可以在运行时发现并加载适当的组件，而无需在代码中硬编码这些组件的实现类。</li><li>在Java中，<strong>SPI</strong>的实现方式是通过在<code>META-INF/services</code>目录下创建一个以服务接口全限定名为名字的文件，文件中包含实现该服务接口的类的全限定名。当应用程序启动时，Java的SPI机制会自动扫描classpath中的这些文件，并根据文件中指定的类名来加载实现类。</li><li>通过使用SPI，应用程序可以实现更灵活、可扩展的架构，同时也可以避免硬编码依赖关系和增加代码的可维护性。</li></ul><p>以上回答来自<code>ChatGPT-3.5</code></p><p>在SpringBoot中，<code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code></p><p>作业：写一段java的spi机制代码</p><h3 id="3-功能开关"><a href="#3-功能开关" class="headerlink" title="3. 功能开关"></a>3. 功能开关</h3><ul><li><p>自动配置：全部都配置好，什么都不用管。   自动批量导入</p></li><li><ul><li>项目一启动，spi文件中指定的所有都加载。</li></ul></li><li><p><code>@EnableXxxx</code>：手动控制哪些功能的开启； 手动导入。</p></li><li><ul><li>开启xxx功能</li><li>都是利用 @Import 把此功能要用的组件导入进去</li></ul></li></ul><h2 id="2-进阶理解"><a href="#2-进阶理解" class="headerlink" title="2. 进阶理解"></a>2. 进阶理解</h2><h3 id="1-SpringBootApplication"><a href="#1-SpringBootApplication" class="headerlink" title="1. @SpringBootApplication"></a>1. @SpringBootApplication</h3><h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h4><p>就是： @Configuration ，容器中的组件，配置类。spring ioc启动就会加载创建这个类对象</p><h4 id="EnableAutoConfiguration：开启自动配置"><a href="#EnableAutoConfiguration：开启自动配置" class="headerlink" title="@EnableAutoConfiguration：开启自动配置"></a>@EnableAutoConfiguration：开启自动配置</h4><p>开启自动配置</p><h5 id="AutoConfigurationPackage：扫描主程序包：加载自己的组件"><a href="#AutoConfigurationPackage：扫描主程序包：加载自己的组件" class="headerlink" title="@AutoConfigurationPackage：扫描主程序包：加载自己的组件"></a>@AutoConfigurationPackage：扫描主程序包：加载自己的组件</h5><ul><li>利用 <code>@Import(AutoConfigurationPackages.Registrar.class)</code> 想要给容器中导入组件。</li><li>把主程序所在的<strong>包</strong>的所有组件导入进来。</li><li><strong>为什么SpringBoot默认只扫描主程序所在的包及其子包</strong></li></ul><h5 id="Import-AutoConfigurationImportSelector-class-：加载所有自动配置类：加载starter导入的组件"><a href="#Import-AutoConfigurationImportSelector-class-：加载所有自动配置类：加载starter导入的组件" class="headerlink" title="@Import(AutoConfigurationImportSelector.class)：加载所有自动配置类：加载starter导入的组件"></a>@Import(AutoConfigurationImportSelector.class)：加载所有自动配置类：加载starter导入的组件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; configurations = ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader())</span><br><span class="line">.getCandidates();</span><br></pre></td></tr></table></figure><p>扫描SPI文件：<code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code></p><h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>组件扫描：排除一些组件（哪些不要）</p><p>排除前面已经扫描进来的<code>配置类</code>、和<code>自动配置类</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br></pre></td></tr></table></figure><h3 id="2-完整启动加载流程"><a href="#2-完整启动加载流程" class="headerlink" title="2. 完整启动加载流程"></a>2. 完整启动加载流程</h3><p>生命周期启动加载流程</p><p><img src="https://i.postimg.cc/25JpYcJ5/1682569555020-b6cbc750-3171-44c6-810f-1c59e590b792.png" alt="img"></p><h1 id="3-自定义starter"><a href="#3-自定义starter" class="headerlink" title="3. 自定义starter"></a>3. 自定义starter</h1><p>场景：<strong>抽取聊天机器人场景，它可以打招呼</strong>。</p><p>效果：任何项目导入此<code>starter</code>都具有打招呼功能，并且<strong>问候语</strong>中的<strong>人名</strong>需要可以在<strong>配置文件</strong>中修改</p><ul><li>\1. 创建<code>自定义starter</code>项目，引入<code>spring-boot-starter</code>基础依赖</li><li>\2. 编写模块功能，引入模块所有需要的依赖。</li><li>\3. 编写<code>xxxAutoConfiguration</code>自动配置类，帮其他项目导入这个模块需要的所有组件</li><li>\4. 编写配置文件<code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>指定启动需要加载的自动配置</li><li>\5. 其他项目引入即可使用</li></ul><h2 id="1-业务代码"><a href="#1-业务代码" class="headerlink" title="1. 业务代码"></a>1. 业务代码</h2><p>自定义配置有提示。导入以下依赖重启项目，再写配置文件就有提示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;robot&quot;)</span>  <span class="comment">//此属性类和配置文件指定前缀绑定</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RobotProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--        导入配置处理器，配置文件自定义的properties配置都会有提示--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-基本抽取"><a href="#2-基本抽取" class="headerlink" title="2. 基本抽取"></a>2. 基本抽取</h2><ul><li>创建starter项目，把公共代码需要的所有依赖导入</li><li>把公共代码复制进来</li><li><p>自己写一个 <code>RobotAutoConfiguration</code>，给容器中导入这个场景需要的所有组件</p></li><li><ul><li>为什么这些组件默认不会扫描进去？</li><li><strong>starter所在的包和 引入它的项目的主程序所在的包不是父子层级</strong></li></ul></li><li><p>别人引用这个<code>starter</code>，直接导入这个 <code>RobotAutoConfiguration</code>,就能把这个场景的组件导入进来</p></li><li>功能生效。</li><li>测试编写配置文件</li></ul><h2 id="3-使用-EnableXxx机制"><a href="#3-使用-EnableXxx机制" class="headerlink" title="3. 使用@EnableXxx机制"></a>3. 使用@EnableXxx机制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(RobotAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableRobot &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别人引入<code>starter</code>需要使用 <code>@EnableRobot</code>开启功能  </p><h2 id="4-完全自动配置"><a href="#4-完全自动配置" class="headerlink" title="4. 完全自动配置"></a>4. 完全自动配置</h2><ul><li>依赖SpringBoot的SPI机制</li><li>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 文件中编写好我们自动配置类的全类名即可</li><li>项目启动，自动加载我们的自动配置类</li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot3-基础特性</title>
      <link href="/2023/07/01/springboot3-%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/"/>
      <url>/2023/07/01/springboot3-%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-SpringApplication"><a href="#1-SpringApplication" class="headerlink" title="1. SpringApplication"></a>1. SpringApplication</h1><h2 id="1-1-自定义-banner"><a href="#1-1-自定义-banner" class="headerlink" title="1.1. 自定义 banner"></a>1.1. 自定义 banner</h2><ol><li>类路径添加banner.txt或设置spring.banner.location就可以定制 banner</li><li>推荐网站：<a href="https://www.bootschool.net/ascii">Spring Boot banner 在线生成工具，制作下载英文 banner.txt，修改替换 banner.txt 文字实现自定义，个性化启动 banner-bootschool.net</a></li></ol><h2 id="1-2-自定义-SpringApplication"><a href="#1-2-自定义-SpringApplication" class="headerlink" title="1.2. 自定义 SpringApplication"></a>1.2. 自定义 SpringApplication</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.Banner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SpringApplication</span> <span class="variable">application</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(MyApplication.class);</span><br><span class="line">        application.setBannerMode(Banner.Mode.OFF);</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-FluentBuilder-API"><a href="#1-3-FluentBuilder-API" class="headerlink" title="1.3. FluentBuilder API"></a>1.3. FluentBuilder API</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">SpringApplicationBuilder</span>()</span><br><span class="line">    .sources(Parent.class)</span><br><span class="line">    .child(Application.class)</span><br><span class="line">    .bannerMode(Banner.Mode.OFF)</span><br><span class="line">    .run(args);</span><br></pre></td></tr></table></figure><h1 id="2-Profiles"><a href="#2-Profiles" class="headerlink" title="2. Profiles"></a>2. Profiles</h1><p>环境隔离能力；快速切换开发、测试、生产环境</p><p>步骤：</p><ol><li><strong>标识环境</strong>：指定哪些组件、配置在哪个环境生效</li><li><strong>切换环境</strong>：这个环境对应的所有组件和配置就应该生效</li></ol><h2 id="2-1-使用"><a href="#2-1-使用" class="headerlink" title="2.1. 使用"></a>2.1. 使用</h2><h3 id="2-1-1-指定环境"><a href="#2-1-1-指定环境" class="headerlink" title="2.1.1 指定环境"></a>2.1.1 指定环境</h3><ul><li>Spring Profiles 提供一种<strong>隔离配置</strong>的方式，使其仅在<strong>特定环境</strong>生效；</li><li>任何@Component, @Configuration 或 @ConfigurationProperties 可以使用 @Profile 标记，来指定何时被加载。【<strong>容器中的组件</strong>都可以被 <code>@Profile</code>标记】</li></ul><h3 id="2-1-2-环境激活"><a href="#2-1-2-环境激活" class="headerlink" title="2.1.2 环境激活"></a>2.1.2 环境激活</h3><ol><li>配置激活指定环境； 配置文件</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">production,hsqldb</span></span><br></pre></td></tr></table></figure><ol><li>也可以使用命令行激活。—spring.profiles.active=dev,hsqldb</li><li><p>还可以配置<strong>默认环境</strong>； 不标注@Profile 的组件永远都存在。</p></li><li><ol><li>以前默认环境叫default</li><li><code>spring.profiles.default=test</code></li></ol></li><li><p>推荐使用激活方式激活指定环境</p></li></ol><h3 id="2-1-3-环境包含"><a href="#2-1-3-环境包含" class="headerlink" title="2.1.3 环境包含"></a>2.1.3 环境包含</h3><p>注意：</p><ol><li>spring.profiles.active 和spring.profiles.default 只能用到 <strong>无 profile 的文件</strong>中，如果在application-dev.yaml中编写就是<strong>无效的</strong></li><li>也可以额外添加生效文件，而不是激活替换。比如：</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.profiles.include[0]</span>=<span class="string">common</span></span><br><span class="line"><span class="attr">spring.profiles.include[1]</span>=<span class="string">local</span></span><br></pre></td></tr></table></figure><p>最佳实战：</p><ul><li><strong>生效的环境</strong> = <strong>激活的环境/默认环境</strong>  + <strong>包含的环境</strong></li><li><p>项目里面这么用</p></li><li><ul><li>基础的配置<code>mybatis</code>、<code>log</code>、<code>xxx</code>：写到<strong>包含环境中</strong></li><li>需要动态切换变化的 <code>db</code>、<code>redis</code>：写到<strong>激活的环境中</strong></li></ul></li></ul><h2 id="2-2-Profile-分组"><a href="#2-2-Profile-分组" class="headerlink" title="2.2. Profile 分组"></a>2.2. Profile 分组</h2><p>创建prod组，指定包含db和mq配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.group.prod[0]=db</span><br><span class="line">spring.profiles.group.prod[1]=mq</span><br></pre></td></tr></table></figure><p>使用—spring.profiles.active=prod ，就会激活prod，db，mq配置文件</p><h2 id="2-3-Profile-配置文件"><a href="#2-3-Profile-配置文件" class="headerlink" title="2.3. Profile 配置文件"></a>2.3. Profile 配置文件</h2><ul><li><code>application-&#123;profile&#125;.properties</code>可以作为<strong>指定环境的配置文件</strong>。</li><li><p>激活这个环境，<strong>配置</strong>就会生效。最终生效的所有<strong>配置</strong>是</p></li><li><ul><li><code>application.properties</code>：主配置文件，任意时候都生效</li><li><code>application-&#123;profile&#125;.properties</code>：指定环境配置文件，激活指定环境生效</li></ul></li></ul><p>profile优先级 &gt; application </p><h1 id="3-外部化配置"><a href="#3-外部化配置" class="headerlink" title="3. 外部化配置"></a>3. 外部化配置</h1><p><strong>场景</strong>：线上应用如何<strong>快速修改配置</strong>，并应<strong>用最新配置</strong>？</p><ul><li>SpringBoot 使用  <strong>配置优先级</strong> + <strong>外部配置</strong>  简化配置更新、简化运维。</li><li>只需要给<code>jar</code>应用所在的文件夹放一个<code>application.properties</code>最新配置文件，重启项目就能自动应用最新配置</li></ul><h2 id="3-1-配置优先级"><a href="#3-1-配置优先级" class="headerlink" title="3.1. 配置优先级"></a>3.1. 配置优先级</h2><p>Spring Boot 允许将<strong>配置外部化</strong>，以便可以在不同的环境中使用相同的应用程序代码。</p><p>我们可以使用各种<strong>外部配置源</strong>，包括Java Properties文件、YAML文件、环境变量和命令行参数。</p><p>@Value可以获取值，也可以用@ConfigurationProperties将所有属性绑定到java object中</p><p><strong>以下是 SpringBoot 属性源加载顺序。**</strong>后面的会覆盖前面的值**。由低到高，高优先级配置覆盖低优先级</p><ol><li><strong>默认属性</strong>（通过<code>SpringApplication.setDefaultProperties</code>指定的）</li><li>@PropertySource指定加载的配置（需要写在@Configuration类上才可生效）</li><li><strong>配置文件（**</strong>application.properties/yml<strong>**等）</strong></li><li>RandomValuePropertySource支持的random.*配置（如：@Value(“${random.int}”)）</li><li>OS 环境变量</li><li>Java 系统属性（System.getProperties()）</li><li>JNDI 属性（来自java:comp/env）</li><li>ServletContext 初始化参数</li><li>ServletConfig 初始化参数</li><li>SPRING_APPLICATION_JSON属性（内置在环境变量或系统属性中的 JSON）</li><li><strong>命令行参数</strong></li><li>测试属性。(@SpringBootTest进行测试时指定的属性)</li><li>测试类@TestPropertySource注解</li><li>Devtools 设置的全局属性。($HOME/.config/spring-boot)</li></ol><p>结论：配置可以写到很多位置，常见的优先级顺序：</p><ul><li><code>命令行</code>&gt; <code>配置文件</code>&gt; <code>springapplication配置</code></li></ul><p><strong>配置文件优先级</strong>如下：(<strong>后面覆盖前面</strong>)</p><ol><li><strong>jar 包内</strong>的application.properties/yml</li><li><strong>jar 包内</strong>的application-{profile}.properties/yml</li><li><strong>jar 包外</strong>的application.properties/yml</li><li><strong>jar 包外</strong>的application-{profile}.properties/yml</li></ol><p><strong>建议</strong>：<strong>用一种格式的配置文件</strong>。<code>**如果****.properties****和****.yml****同时存在,则****.properties****优先**</code></p><p>结论：<code>包外 &gt; 包内</code>； 同级情况：<code>profile配置 &gt; application配置</code></p><p><strong>所有参数均可由命令行传入，使用</strong><code>**--参数项=参数值**</code><strong>，将会被添加到环境变量中，并优先于</strong><code>**配置文件**</code><strong>。</strong></p><p><strong>比如</strong><code>**java -jar app.jar --name=&quot;Spring&quot;**</code><strong>,可以使用</strong><code>**@Value(&quot;$&#123;name&#125;&quot;)**</code><strong>获取</strong></p><p>演示场景：</p><ul><li>包内： application.properties   <code>server.port=8000</code></li><li>包内： application-dev.properties    <code>server.port=9000</code></li><li>包外：  application.properties   <code>server.port=8001</code></li><li>包外： application-dev.properties    <code>server.port=9001</code></li></ul><p>启动端口？：命令行 &gt; <code>9001</code> &gt; <code>8001</code> &gt; <code>9000</code> &gt; <code>8000</code></p><h2 id="3-2-外部配置"><a href="#3-2-外部配置" class="headerlink" title="3.2. 外部配置"></a>3.2. 外部配置</h2><p>SpringBoot 应用启动时会自动寻找application.properties和application.yaml位置，进行加载。顺序如下：（<strong>后面覆盖前面</strong>）</p><ol><li><p>类路径: 内部</p></li><li><ol><li>类根路径</li><li>类下/config包</li></ol></li><li><p>当前路径（项目所在的位置）</p></li><li><ol><li>当前路径</li><li>当前下/config子目录</li><li>/config目录的直接子目录</li></ol></li></ol><p>最终效果：优先级由高到低，前面覆盖后面</p><ul><li>命令行 &gt; 包外config直接子目录 &gt; 包外config目录 &gt; 包外根目录 &gt; 包内目录</li><li><p>同级比较： </p></li><li><ul><li>profile配置 &gt; 默认配置</li><li>properties配置 &gt; yaml配置</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/svg/1613913/1682073869709-2cba18c8-55bd-4bf1-a9df-ac784e30d89a.svg" alt="img"></p><p>规律：最外层的最优先。</p><ul><li>命令行 &gt; 所有</li><li>包外 &gt; 包内</li><li>config目录 &gt; 根目录</li><li>profile &gt; application </li></ul><p>配置不同就都生效（互补），配置相同高优先级覆盖低优先级</p><h2 id="3-3-导入配置"><a href="#3-3-导入配置" class="headerlink" title="3.3. 导入配置"></a>3.3. 导入配置</h2><p>使用spring.config.import可以导入额外配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.config.import=my.properties</span><br><span class="line">my.property=value</span><br></pre></td></tr></table></figure><p>无论以上写法的先后顺序，my.properties的值总是优先于直接在文件中编写的my.property。</p><h2 id="3-4-属性占位符"><a href="#3-4-属性占位符" class="headerlink" title="3.4. 属性占位符"></a>3.4. 属性占位符</h2><p>配置文件中可以使用 ${name:default}形式取出之前配置过的值。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app.name</span>=<span class="string">MyApp</span></span><br><span class="line"><span class="attr">app.description</span>=<span class="string">$&#123;app.name&#125; is a Spring Boot application written by $&#123;username:Unknown&#125;</span></span><br></pre></td></tr></table></figure><h1 id="4-单元测试-JUnit5"><a href="#4-单元测试-JUnit5" class="headerlink" title="4. 单元测试-JUnit5"></a>4. 单元测试-JUnit5</h1><h2 id="4-1-整合"><a href="#4-1-整合" class="headerlink" title="4.1. 整合"></a>4.1. 整合</h2><p>SpringBoot 提供一系列测试工具集及注解方便我们进行测试。</p><p>spring-boot-test提供核心测试能力，spring-boot-test-autoconfigure 提供测试的一些自动配置。</p><p>我们只需要导入spring-boot-starter-test 即可整合测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>spring-boot-starter-test 默认提供了以下库供我们测试使用</p><ul><li><a href="https://junit.org/junit5/">JUnit 5</a></li><li><a href="https://docs.spring.io/spring-framework/docs/6.0.4/reference/html/testing.html#integration-testing">Spring Test</a></li><li><a href="https://assertj.github.io/doc/">AssertJ</a></li><li><a href="https://github.com/hamcrest/JavaHamcrest">Hamcrest</a></li><li><a href="https://site.mockito.org/">Mockito</a></li><li><a href="https://github.com/skyscreamer/JSONassert">JSONassert</a></li><li><a href="https://github.com/jayway/JsonPath">JsonPath</a></li></ul><h2 id="4-2-测试"><a href="#4-2-测试" class="headerlink" title="4.2. 测试"></a>4.2. 测试</h2><h3 id="4-2-0-组件测试"><a href="#4-2-0-组件测试" class="headerlink" title="4.2.0 组件测试"></a>4.2.0 组件测试</h3><p>直接<code>@Autowired</code>容器中的组件进行测试</p><h3 id="4-2-1-注解"><a href="#4-2-1-注解" class="headerlink" title="4.2.1 注解"></a>4.2.1 注解</h3><p>JUnit5的注解与JUnit4的注解有所变化</p><p><a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations">https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations</a></p><ul><li><strong>@Test :</strong>表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试</li><li><strong>@ParameterizedTest :</strong>表示方法是参数化测试，下方会有详细介绍</li><li><strong>@RepeatedTest :</strong>表示方法可重复执行，下方会有详细介绍</li><li><strong>@DisplayName :</strong>为测试类或者测试方法设置展示名称</li><li><strong>@BeforeEach :</strong>表示在每个单元测试之前执行</li><li><strong>@AfterEach :</strong>表示在每个单元测试之后执行</li><li><strong>@BeforeAll :</strong>表示在所有单元测试之前执行</li><li><strong>@AfterAll :</strong>表示在所有单元测试之后执行</li><li><strong>@Tag :</strong>表示单元测试类别，类似于JUnit4中的@Categories</li><li><strong>@Disabled :</strong>表示测试类或测试方法不执行，类似于JUnit4中的@Ignore</li><li><strong>@Timeout :</strong>表示测试方法运行如果超过了指定时间将会返回错误</li><li><strong>@ExtendWith :</strong>为测试类或测试方法提供扩展类引用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.fail;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assumptions.assumeTrue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Disabled;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StandardTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initAll</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DisplayName(&quot;😱&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">succeedingTest</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">failingTest</span><span class="params">()</span> &#123;</span><br><span class="line">        fail(<span class="string">&quot;a failing test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Disabled(&quot;for demonstration purposes&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">skippedTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// not executed</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abortedTest</span><span class="params">()</span> &#123;</span><br><span class="line">        assumeTrue(<span class="string">&quot;abc&quot;</span>.contains(<span class="string">&quot;Z&quot;</span>));</span><br><span class="line">        fail(<span class="string">&quot;test should have been aborted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">tearDownAll</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-断言"><a href="#4-2-2-断言" class="headerlink" title="4.2.2 断言"></a>4.2.2 断言</h3><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>assertEquals</td><td>判断两个对象或两个原始类型是否相等</td></tr><tr><td>assertNotEquals</td><td>判断两个对象或两个原始类型是否不相等</td></tr><tr><td>assertSame</td><td>判断两个对象引用是否指向同一个对象</td></tr><tr><td>assertNotSame</td><td>判断两个对象引用是否指向不同的对象</td></tr><tr><td>assertTrue</td><td>判断给定的布尔值是否为 true</td></tr><tr><td>assertFalse</td><td>判断给定的布尔值是否为 false</td></tr><tr><td>assertNull</td><td>判断给定的对象引用是否为 null</td></tr><tr><td>assertNotNull</td><td>判断给定的对象引用是否不为 null</td></tr><tr><td>assertArrayEquals</td><td>数组断言</td></tr><tr><td>assertAll</td><td>组合断言</td></tr><tr><td>assertThrows</td><td>异常断言</td></tr><tr><td>assertTimeout</td><td>超时断言</td></tr><tr><td>fail</td><td>快速失败</td></tr></tbody></table></div><h3 id="4-2-3-嵌套测试"><a href="#4-2-3-嵌套测试" class="headerlink" title="4.2.3 嵌套测试"></a>4.2.3 嵌套测试</h3><p>JUnit 5 可以通过 Java 中的内部类和@Nested 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起。在内部类中可以使用@BeforeEach 和@AfterEach 注解，而且嵌套的层次没有限制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;A stack&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestingAStackDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Object&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;is instantiated with new Stack()&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">isInstantiatedWithNew</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;when new&quot;)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WhenNew</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@BeforeEach</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">createNewStack</span><span class="params">()</span> &#123;</span><br><span class="line">            stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;is empty&quot;)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">            assertTrue(stack.isEmpty());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;throws EmptyStackException when popped&quot;)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">throwsExceptionWhenPopped</span><span class="params">()</span> &#123;</span><br><span class="line">            assertThrows(EmptyStackException.class, stack::pop);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;throws EmptyStackException when peeked&quot;)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">throwsExceptionWhenPeeked</span><span class="params">()</span> &#123;</span><br><span class="line">            assertThrows(EmptyStackException.class, stack::peek);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nested</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;after pushing an element&quot;)</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">AfterPushing</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">anElement</span> <span class="operator">=</span> <span class="string">&quot;an element&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@BeforeEach</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">pushAnElement</span><span class="params">()</span> &#123;</span><br><span class="line">                stack.push(anElement);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Test</span></span><br><span class="line">            <span class="meta">@DisplayName(&quot;it is no longer empty&quot;)</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">isNotEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">                assertFalse(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Test</span></span><br><span class="line">            <span class="meta">@DisplayName(&quot;returns the element when popped and is empty&quot;)</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">returnElementWhenPopped</span><span class="params">()</span> &#123;</span><br><span class="line">                assertEquals(anElement, stack.pop());</span><br><span class="line">                assertTrue(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Test</span></span><br><span class="line">            <span class="meta">@DisplayName(&quot;returns the element when peeked but remains not empty&quot;)</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">returnElementWhenPeeked</span><span class="params">()</span> &#123;</span><br><span class="line">                assertEquals(anElement, stack.peek());</span><br><span class="line">                assertFalse(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-4-参数化测试"><a href="#4-2-4-参数化测试" class="headerlink" title="4.2.4 参数化测试"></a>4.2.4 参数化测试</h3><p>参数化测试是JUnit5很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。</p><p>利用<strong>@ValueSource</strong>等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。</p><p><strong>@ValueSource</strong>: 为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型</p><p><strong>@NullSource</strong>: 表示为参数化测试提供一个null的入参</p><p><strong>@EnumSource</strong>: 表示为参数化测试提供一个枚举入参</p><p><strong>@CsvFileSource</strong>：表示读取指定CSV文件内容作为参数化测试入参</p><p><strong>@MethodSource</strong>：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(strings = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;)</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;参数化测试1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parameterizedTest1</span><span class="params">(String string)</span> &#123;</span><br><span class="line">    System.out.println(string);</span><br><span class="line">    Assertions.assertTrue(StringUtils.isNotBlank(string));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@MethodSource(&quot;method&quot;)</span>    <span class="comment">//指定方法名</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;方法来源参数&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWithExplicitLocalMethodSource</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    Assertions.assertNotNull(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Stream&lt;String&gt; <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot3-快速入门</title>
      <link href="/2023/06/30/springboot3-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2023/06/30/springboot3-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h1><h2 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1. 前置知识"></a>1. 前置知识</h2><ul><li>Java17</li><li>Spring、SpringMVC、MyBatis</li><li>Maven、IDEA</li></ul><h2 id="2-环境要求"><a href="#2-环境要求" class="headerlink" title="2. 环境要求"></a>2. 环境要求</h2><div class="table-container"><table><thead><tr><th>环境&amp;工具</th><th>版本（or later）</th></tr></thead><tbody><tr><td>SpringBoot</td><td>3.0.5+</td></tr><tr><td>IDEA</td><td>2021.2.1+</td></tr><tr><td>Java</td><td>17+</td></tr><tr><td>Maven</td><td>3.5+</td></tr><tr><td>Tomcat</td><td>10.0+</td></tr><tr><td>Servlet</td><td>5.0+</td></tr><tr><td>GraalVM Community</td><td>22.3+</td></tr><tr><td>Native Build Tools</td><td>0.9.19+</td></tr></tbody></table></div><h2 id="3-SpringBoot是什么"><a href="#3-SpringBoot是什么" class="headerlink" title="3. SpringBoot是什么"></a>3. SpringBoot是什么</h2><p>SpringBoot 帮我们简单、快速地创建一个独立的、生产级别的 <strong>Spring 应用（说明：SpringBoot底层是Spring）</strong></p><p>大多数 SpringBoot 应用只需要编写少量配置即可快速整合 Spring 平台以及第三方技术</p><p><strong>特性：</strong></p><ul><li><p>快速创建独立 Spring 应用</p></li><li><ul><li>SSM：导包、写配置、启动运行</li></ul></li><li><p>直接嵌入Tomcat、Jetty or Undertow（无需部署 war 包）【Servlet容器】</p></li><li><ul><li>linux  java tomcat mysql： war 放到 tomcat 的 webapps下</li><li>jar： java环境；  java -jar</li></ul></li><li><p><strong>重点</strong>：提供可选的starter，简化应用<strong>整合</strong></p></li><li><ul><li><strong>场景启动器</strong>（starter）：web、json、邮件、oss（对象存储）、异步、定时任务、缓存…</li><li>导包一堆，控制好版本。</li><li>为每一种场景准备了一个依赖； <strong>web-starter。mybatis-starter</strong></li></ul></li><li><p><strong>重点：</strong>按需自动配置 Spring 以及 第三方库</p></li><li><ul><li>如果这些场景我要使用（生效）。这个场景的所有配置都会自动配置好。</li><li><strong>约定大于配置</strong>：每个场景都有很多默认配置。</li><li>自定义：配置文件中修改几项就可以</li></ul></li><li><p>提供生产级特性：如 监控指标、健康检查、外部化配置等</p></li><li><ul><li>监控指标、健康检查（k8s）、外部化配置</li></ul></li><li><p>无代码生成、无xml</p></li></ul><p>总结：简化开发，简化配置，简化整合，简化部署，简化监控，简化运维。</p><h1 id="2、快速体验"><a href="#2、快速体验" class="headerlink" title="2、快速体验"></a>2、快速体验</h1><p>场景：浏览器发送<strong>/hello</strong>请求，返回”<strong>Hello,Spring Boot 3!</strong>“</p><h2 id="1-开发流程"><a href="#1-开发流程" class="headerlink" title="1. 开发流程"></a>1. 开发流程</h2><h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h3><p>maven 项目</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    所有springboot项目都必须继承自 spring-boot-starter-parent --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-导入场景"><a href="#2-导入场景" class="headerlink" title="2. 导入场景"></a>2. 导入场景</h3><p>场景启动器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        web开发的场景启动器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-主程序"><a href="#3-主程序" class="headerlink" title="3. 主程序"></a>3. 主程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span> <span class="comment">//这是一个SpringBoot应用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-业务"><a href="#4-业务" class="headerlink" title="4. 业务"></a>4. 业务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello,Spring Boot 3!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h3><p>默认启动访问： localhost:8080</p><h3 id="6-打包"><a href="#6-打包" class="headerlink" title="6. 打包"></a>6. 打包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    SpringBoot应用打包插件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>mvn clean package</code>把项目打成可执行的jar包</p><p><code>java -jar demo.jar</code>启动项目</p><h2 id="2-特性小结"><a href="#2-特性小结" class="headerlink" title="2. 特性小结"></a>2. 特性小结</h2><h3 id="1-简化整合"><a href="#1-简化整合" class="headerlink" title="1. 简化整合"></a>1. 简化整合</h3><p>导入相关的场景，拥有相关的功能。场景启动器</p><p>默认支持的所有场景：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters">https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters</a></p><ul><li>官方提供的场景：命名为：<code>spring-boot-starter-*</code></li><li>第三方提供场景：命名为：<code>*-spring-boot-starter</code></li></ul><p>场景一导入，万物皆就绪</p><h3 id="2-简化开发"><a href="#2-简化开发" class="headerlink" title="2. 简化开发"></a>2. 简化开发</h3><p>无需编写任何配置，直接开发业务</p><h3 id="3-简化配置"><a href="#3-简化配置" class="headerlink" title="3. 简化配置"></a>3. 简化配置</h3><p><code>application.properties</code>：</p><ul><li>集中式管理配置。只需要修改这个文件就行 。</li><li>配置基本都有默认值</li><li>能写的所有配置都在： <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties">https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties</a></li></ul><h3 id="4-简化部署"><a href="#4-简化部署" class="headerlink" title="4. 简化部署"></a>4. 简化部署</h3><p>打包为可执行的jar包。</p><p>linux服务器上有java环境。</p><h3 id="5-简化运维"><a href="#5-简化运维" class="headerlink" title="5. 简化运维"></a>5. 简化运维</h3><p>修改配置（外部放一个application.properties文件）、监控、健康检查。</p><p>…..</p><h2 id="3-Spring-Initializr-创建向导"><a href="#3-Spring-Initializr-创建向导" class="headerlink" title="3. Spring Initializr 创建向导"></a>3. Spring Initializr 创建向导</h2><p>一键创建好整个项目结构</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1679922435118-bde3347e-b9fe-4138-8e16-0c231884ea5f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_39%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" alt="img"></p><h1 id="3、应用分析"><a href="#3、应用分析" class="headerlink" title="3、应用分析"></a>3、应用分析</h1><h2 id="1-依赖管理机制"><a href="#1-依赖管理机制" class="headerlink" title="1. 依赖管理机制"></a>1. 依赖管理机制</h2><p>思考：</p><p>1、为什么导入<code>starter-web</code>所有相关依赖都导入进来？</p><ul><li>开发什么场景，导入什么<strong>场景启动器。</strong></li><li><strong>maven依赖传递原则。A-B-C： A就拥有B和C</strong></li><li>导入 场景启动器。 场景启动器 自动把这个场景的所有核心依赖全部导入进来</li></ul><p>2、为什么版本号都不用写？</p><ul><li>每个boot项目都有一个父项目<code>spring-boot-starter-parent</code></li><li>parent的父项目是<code>spring-boot-dependencies</code></li><li>父项目 <strong>版本仲裁中心</strong>，把所有常见的jar的依赖版本都声明好了。</li><li>比如：<code>mysql-connector-j</code></li></ul><p>3、自定义版本号</p><ul><li><p>利用maven的就近原则</p></li><li><ul><li>直接在当前项目<code>properties</code>标签中声明父项目用的版本属性的key</li><li>直接在<strong>导入依赖的时候声明版本</strong></li></ul></li></ul><p>4、第三方的jar包</p><ul><li>boot父项目没有管理的需要自行声明好</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1679294529375-4ee1cd26-8ebc-4abf-bff9-f8775e10c927.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_25%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" alt="img"></p><h2 id="2-自动配置机制"><a href="#2-自动配置机制" class="headerlink" title="2. 自动配置机制"></a>2. 自动配置机制</h2><h3 id="1-初步理解"><a href="#1-初步理解" class="headerlink" title="1. 初步理解"></a>1. 初步理解</h3><ul><li><p><strong>自动配置</strong>的 Tomcat、SpringMVC 等</p></li><li><ul><li><strong>导入场景</strong>，容器中就会自动配置好这个场景的核心组件。</li><li>以前：DispatcherServlet、ViewResolver、CharacterEncodingFilter….</li><li>现在：自动配置好的这些组件</li><li>验证：<strong>容器中有了什么组件，就具有什么功能</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//java10： 局部变量类型的自动推断</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">ioc</span> <span class="operator">=</span> SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、获取容器中所有组件的名字</span></span><br><span class="line">    String[] names = ioc.getBeanDefinitionNames();</span><br><span class="line">    <span class="comment">//2、挨个遍历：</span></span><br><span class="line">    <span class="comment">// dispatcherServlet、beanNameViewResolver、characterEncodingFilter、multipartResolver</span></span><br><span class="line">    <span class="comment">// SpringBoot把以前配置的核心组件现在都给我们自动配置好了。</span></span><br><span class="line">    <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>默认的包扫描规则</strong></p></li><li><ul><li><code>@SpringBootApplication</code> 标注的类就是主程序类</li><li><strong>SpringBoot只会扫描主程序所在的包及其下面的子包，自动的component-scan功能</strong></li><li><strong>自定义扫描路径</strong></li></ul></li><li><ul><li><ul><li>@SpringBootApplication(scanBasePackages = “com.atguigu”)</li><li><code>@ComponentScan(&quot;com.atguigu&quot;)</code> 直接指定扫描的路径</li></ul></li></ul></li><li><p><strong>配置默认值</strong></p></li><li><ul><li><strong>配置文件</strong>的所有配置项是和某个<strong>类的对象</strong>值进行一一绑定的。</li><li>绑定了配置文件中每一项值的类： <strong>属性类</strong>。</li><li>比如：</li></ul></li><li><ul><li><ul><li><code>ServerProperties</code>绑定了所有Tomcat服务器有关的配置</li><li><code>MultipartProperties</code>绑定了所有文件上传相关的配置</li><li>….参照<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.server">官方文档</a>：或者参照 绑定的  <strong>属性类</strong>。</li></ul></li></ul></li><li><p>按需加载自动配置</p></li><li><ul><li>导入场景<code>spring-boot-starter-web</code></li><li>场景启动器除了会导入相关功能依赖，导入一个<code>spring-boot-starter</code>，是所有<code>starter</code>的<code>starter</code>，基础核心starter</li><li><code>spring-boot-starter</code>导入了一个包 <code>spring-boot-autoconfigure</code>。包里面都是各种场景的<code>AutoConfiguration</code><strong>自动配置类</strong></li><li>虽然全场景的自动配置都在 <code>spring-boot-autoconfigure</code>这个包，但是不是全都开启的。</li></ul></li><li><ul><li><ul><li>导入哪个场景就开启哪个自动配置</li></ul></li></ul></li></ul><p>总结： 导入场景启动器、触发 <code>spring-boot-autoconfigure</code>这个包的自动配置生效、容器中就会具有相关场景的功能</p><h3 id="2-完整流程"><a href="#2-完整流程" class="headerlink" title="2. 完整流程"></a>2. 完整流程</h3><p>思考：</p><p><strong>1、SpringBoot怎么实现导一个</strong><code>**starter**</code><strong>、写一些简单配置，应用就能跑起来，我们无需关心整合</strong></p><p>2、为什么Tomcat的端口号可以配置在<code>application.properties</code>中，并且<code>Tomcat</code>能启动成功？</p><p>3、导入场景后哪些<strong>自动配置能生效</strong>？</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1679970508234-3c6b8ecc-6372-4eb5-8c67-563054d1a72d.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_37%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" alt="img"></p><p><strong><em>自动配置流程细节梳理：</em></strong></p><p><strong>1、</strong>导入<code>starter-web</code>：导入了web开发场景</p><ul><li>1、场景启动器导入了相关场景的所有依赖：<code>starter-json</code>、<code>starter-tomcat</code>、<code>springmvc</code></li><li>2、每个场景启动器都引入了一个<code>spring-boot-starter</code>，核心场景启动器。</li><li>3、<strong>核心场景启动器</strong>引入了<code>spring-boot-autoconfigure</code>包。</li><li>4、<code>spring-boot-autoconfigure</code>里面囊括了所有场景的所有配置。</li><li>5、只要这个包下的所有类都能生效，那么相当于SpringBoot官方写好的整合功能就生效了。</li><li>6、SpringBoot默认却扫描不到 <code>spring-boot-autoconfigure</code>下写好的所有<strong>配置类</strong>。（这些<strong>配置类</strong>给我们做了整合操作），<strong>默认只扫描主程序所在的包</strong>。</li></ul><p><strong>2、**</strong>主程序**：<code>@SpringBootApplication</code></p><ul><li>1、<code>@SpringBootApplication</code>由三个注解组成<code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguratio</code>、<code>@ComponentScan</code></li><li>2、SpringBoot默认只能扫描自己主程序所在的包及其下面的子包，扫描不到 <code>spring-boot-autoconfigure</code>包中官方写好的<strong>配置类</strong></li><li><p>3、<code>**@EnableAutoConfiguration**</code>：SpringBoot <strong>开启自动配置的核心</strong>。</p></li><li><ul><li>\1. 是由<code>@Import(AutoConfigurationImportSelector.class)</code>提供功能：批量给容器中导入组件。</li><li>\2. SpringBoot启动会默认加载 142个配置类。</li><li>\3. 这<strong>142个配置类</strong>来自于<code>spring-boot-autoconfigure</code>下 <code>META-INF/spring/**org.springframework.boot.autoconfigure.AutoConfiguration**.imports</code>文件指定的</li><li>项目启动的时候利用 @Import 批量导入组件机制把 <code>autoconfigure</code> 包下的142 <code>xxxxAutoConfiguration</code>类导入进来（<strong>自动配置类</strong>）</li><li>虽然导入了<code>142</code>个自动配置类</li></ul></li><li><p>4、按需生效：</p></li><li><ul><li>并不是这<code>142</code>个自动配置类都能生效</li><li>每一个自动配置类，都有条件注解<code>@ConditionalOnxxx</code>，只有条件成立，才能生效 </li></ul></li></ul><p><strong>3、</strong><code>**xxxxAutoConfiguration**</code><strong>自动配置类</strong></p><ul><li><strong>1、给容器中使用@Bean 放一堆组件。</strong></li><li>2、每个<strong>自动配置类</strong>都可能有这个注解<code>@EnableConfigurationProperties(**ServerProperties**.class)</code>，用来把配置文件中配的指定前缀的属性值封装到 <code>xxxProperties</code><strong>属性类</strong>中</li><li>3、以Tomcat为例：把服务器的所有配置都是以<code>server</code>开头的。配置都封装到了属性类中。</li><li>4、给<strong>容器</strong>中放的所有<strong>组件</strong>的一些<strong>核心参数</strong>，都来自于<code>**xxxProperties**</code><strong>。</strong><code>**xxxProperties**</code><strong>都是和配置文件绑定。</strong></li><li><strong>只需要改配置文件的值，核心组件的底层参数都能修改</strong></li></ul><p><strong>4、</strong>写业务，全程无需关心各种整合（底层这些整合写好了，而且也生效了）</p><p><strong>核心流程总结：</strong></p><p>1、导入<code>starter</code>，就会导入<code>autoconfigure</code>包。</p><p>2、<code>autoconfigure</code> 包里面 有一个文件 <code>META-INF/spring/**org.springframework.boot.autoconfigure.AutoConfiguration**.imports</code>,里面指定的所有启动要加载的自动配置类</p><p>3、@EnableAutoConfiguration 会自动的把上面文件里面写的所有<strong>自动配置类都导入进来。xxxAutoConfiguration 是有条件注解进行按需加载</strong></p><p>4、<code>xxxAutoConfiguration</code>给容器中导入一堆组件，组件都是从 <code>xxxProperties</code>中提取属性值</p><p>5、<code>xxxProperties</code>又是和<strong>配置文件</strong>进行了绑定</p><p><strong>效果：</strong>导入<code>starter</code>、修改配置文件，就能修改底层行为。</p><h3 id="3-如何学好SpringBoot"><a href="#3-如何学好SpringBoot" class="headerlink" title="3. 如何学好SpringBoot"></a>3. 如何学好SpringBoot</h3><p>框架的框架、底层基于Spring。能调整每一个场景的底层行为。100%项目一定会用到<strong>底层自定义</strong></p><p>摄影：</p><ul><li>傻瓜：自动配置好。</li><li><strong>单反</strong>：焦距、光圈、快门、感光度….</li><li>傻瓜+<strong>单反</strong>：</li></ul><ol><li><p>理解<strong>自动配置原理</strong></p></li><li><ol><li><strong>导入starter</strong> <strong>—&gt; 生效xxxxAutoConfiguration —&gt;</strong> <strong>组件</strong> <strong>—&gt; xxxProperties —&gt;</strong> <strong>配置文件</strong></li></ol></li><li><p>理解<strong>其他框架底层</strong></p></li><li><ol><li>拦截器</li></ol></li><li><p>可以随时<strong>定制化任何组件</strong></p></li><li><ol><li><strong>配置文件</strong></li><li><strong>自定义组件</strong></li></ol></li></ol><p>普通开发：<code>导入starter</code>，Controller、Service、Mapper、偶尔修改配置文件</p><p><strong>高级开发</strong>：自定义组件、自定义配置、自定义starter</p><p>核心：</p><ul><li>这个场景自动配置导入了哪些组件，我们能不能Autowired进来使用</li><li>能不能通过修改配置改变组件的一些默认参数</li><li>需不需要自己完全定义这个组件</li><li>场景定制化</li></ul><p><strong>最佳实战</strong>：</p><ul><li><p><strong>选场景</strong>，导入到项目</p></li><li><ul><li>官方：starter</li><li>第三方：去仓库搜</li></ul></li><li><p><strong>写配置，改配置文件关键项</strong></p></li><li><ul><li>数据库参数（连接地址、账号密码…）</li></ul></li><li><p>分析这个场景给我们导入了<strong>哪些能用的组件</strong></p></li><li><ul><li><strong>自动装配</strong>这些组件进行后续使用</li><li>不满意boot提供的自动配好的默认组件</li></ul></li><li><ul><li><ul><li><strong>定制化</strong></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>改配置</li><li>自定义组件</li></ul></li></ul></li></ul></li></ul><p>整合redis：</p><ul><li><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters">选场景</a>：<code>spring-boot-starter-data-redis</code></p></li><li><ul><li>场景AutoConfiguration 就是这个场景的自动配置类</li></ul></li><li><p>写配置：</p></li><li><ul><li>分析到这个场景的自动配置类开启了哪些属性绑定关系</li><li><code>@EnableConfigurationProperties(RedisProperties.class)</code></li><li>修改redis相关的配置</li></ul></li><li><p>分析组件：</p></li><li><ul><li>分析到 <code>RedisAutoConfiguration</code>  给容器中放了 <code>StringRedisTemplate</code></li><li>给业务代码中自动装配 <code>StringRedisTemplate</code></li></ul></li><li><p>定制化</p></li><li><ul><li>修改配置文件</li><li>由于组件上有<code>@ConditionalOnMissingBean</code>注解，我们就可以自定义组件，自己给容器中放一个 <code>StringRedisTemplate</code></li></ul></li></ul><h1 id="4、核心技能"><a href="#4、核心技能" class="headerlink" title="4、核心技能"></a>4、核心技能</h1><h2 id="1-常用注解"><a href="#1-常用注解" class="headerlink" title="1. 常用注解"></a>1. 常用注解</h2><p>SpringBoot摒弃XML配置方式，改为<strong>全注解驱动</strong></p><h3 id="1-组件注册"><a href="#1-组件注册" class="headerlink" title="1. 组件注册"></a>1. 组件注册</h3><p><strong>@Configuration</strong>、<strong>@SpringBootConfiguration</strong></p><p><strong>@Bean</strong>、<strong>@Scope</strong></p><p><strong>@Controller、 @Service、@Repository、@Component</strong></p><p><strong>@Import</strong></p><p>@ComponentScan</p><p>步骤：</p><p><strong>1、@Configuration 编写一个配置类</strong></p><p><strong>2、在配置类中，自定义方法给容器中注册组件。配合@Bean</strong></p><p><strong>3、或使用@Import 导入第三方的组件</strong></p><h3 id="2-条件注解"><a href="#2-条件注解" class="headerlink" title="2. 条件注解"></a>2. 条件注解</h3><p>如果注解指定的<strong>条件成立</strong>，则触发指定行为</p><p><strong><em>@ConditionalOnXxx</em></strong></p><p><strong>@ConditionalOnClass：如果类路径中存在这个类，则触发指定行为</strong></p><p><strong>@ConditionalOnMissingClass：如果类路径中不存在这个类，则触发指定行为</strong></p><p><strong>@ConditionalOnBean：如果容器中存在这个Bean（组件），则触发指定行为</strong></p><p><strong>@ConditionalOnMissingBean：如果容器中不存在这个Bean（组件），则触发指定行为</strong></p><p>场景：</p><ul><li>如果存在<code>FastsqlException</code>这个类，给容器中放一个<code>Cat</code>组件，名cat01，</li><li>否则，就给容器中放一个<code>Dog</code>组件，名dog01</li><li>如果系统中有<code>dog01</code>这个组件，就给容器中放一个 User组件，名zhangsan </li><li>否则，就放一个User，名叫lisi</li></ul><p><strong>@ConditionalOnBean（value=组件类型，name=组件名字）：判断容器中是否有这个类型的组件，并且名字是指定的值</strong></p><p>@ConditionalOnRepositoryType (org.springframework.boot.autoconfigure.data)<br>@ConditionalOnDefaultWebSecurity (org.springframework.boot.autoconfigure.security)<br>@ConditionalOnSingleCandidate (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnWebApplication (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnWarDeployment (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnJndi (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnResource (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnExpression (org.springframework.boot.autoconfigure.condition)<br><strong>@ConditionalOnClass</strong> (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnEnabledResourceChain (org.springframework.boot.autoconfigure.web)<br><strong>@ConditionalOnMissingClass</strong> (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnNotWebApplication (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnProperty (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnCloudPlatform (org.springframework.boot.autoconfigure.condition)<br><strong>@ConditionalOnBean</strong> (org.springframework.boot.autoconfigure.condition)<br><strong>@ConditionalOnMissingBean</strong> (org.springframework.boot.autoconfigure.condition)<br>@ConditionalOnMissingFilterBean (org.springframework.boot.autoconfigure.web.servlet)<br>@Profile (org.springframework.context.annotation)<br>@ConditionalOnInitializedRestarter (org.springframework.boot.devtools.restart)<br>@ConditionalOnGraphQlSchema (org.springframework.boot.autoconfigure.graphql)<br>@ConditionalOnJava (org.springframework.boot.autoconfigure.condition)</p><h3 id="3-属性绑定"><a href="#3-属性绑定" class="headerlink" title="3. 属性绑定"></a>3. 属性绑定</h3><p><strong>@ConfigurationProperties： 声明组件的属性和配置文件哪些前缀开始项进行绑定</strong></p><p><strong>@EnableConfigurationProperties：快速注册注解：</strong></p><ul><li><strong>场景：</strong>SpringBoot默认只扫描自己主程序所在的包。如果导入第三方包，即使组件上标注了 @Component、@ConfigurationProperties 注解，也没用。因为组件都扫描不进来，此时使用这个注解就可以快速进行属性绑定并把组件注册进容器</li></ul><p>将容器中任意<strong>组件（Bean）的属性值</strong>和<strong>配置文件</strong>的配置项的值<strong>进行绑定</strong></p><ul><li><strong>1、给容器中注册组件（@Component、@Bean）</strong></li><li><strong>2、使用**</strong>@ConfigurationProperties 声明组件和配置文件的哪些配置项进行绑定**</li></ul><p>更多注解参照：<a href="https://www.bilibili.com/video/BV1gW411W7wy">Spring注解驱动开发</a>【1-26集】</p><h2 id="2-YAML配置文件"><a href="#2-YAML配置文件" class="headerlink" title="2. YAML配置文件"></a>2. YAML配置文件</h2><p><strong>痛点</strong>：SpringBoot 集中化管理配置，<code>application.properties</code></p><p><strong>问题</strong>：配置多以后难阅读和修改，<strong>层级结构辨识度不高</strong></p><p>YAML 是 “YAML Ain’t a Markup Language”（YAML 不是一种标记语言）。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（是另一种标记语言）。</p><ul><li>设计目标，就是<strong>方便人类读写</strong></li><li><strong>层次分明</strong>，更适合做配置文件</li><li>使用<code>.yaml</code>或 <code>.yml</code>作为文件后缀</li></ul><h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h3><ul><li><strong>大小写敏感</strong></li><li>使用<strong>缩进表示层级关系，k: v，使用空格分割k,v</strong></li><li>缩进时不允许使用Tab键，只允许<strong>使用空格</strong>。换行</li><li>缩进的空格数目不重要，只要<strong>相同层级</strong>的元素<strong>左侧对齐</strong>即可</li><li><strong># 表示注释</strong>，从这个字符一直到行尾，都会被解析器忽略。</li></ul><p>支持的写法：</p><ul><li><strong>对象</strong>：<strong>键值对</strong>的集合，如：映射（map）/ 哈希（hash） / 字典（dictionary）</li><li><strong>数组</strong>：一组按次序排列的值，如：序列（sequence） / 列表（list）</li><li><strong>纯量</strong>：单个的、不可再分的值，如：字符串、数字、bool、日期</li></ul><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span> <span class="comment">//和配置文件person前缀的所有配置进行绑定</span></span><br><span class="line"><span class="meta">@Data</span> <span class="comment">//自动生成JavaBean属性的getter/setter</span></span><br><span class="line"><span class="comment">//@NoArgsConstructor //自动生成无参构造器</span></span><br><span class="line"><span class="comment">//@AllArgsConstructor //自动生成全参构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date birthDay;</span><br><span class="line">    <span class="keyword">private</span> Boolean like;</span><br><span class="line">    <span class="keyword">private</span> Child child; <span class="comment">//嵌套对象</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Dog&gt; dogs; <span class="comment">//数组（里面是对象）</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Cat&gt; cats; <span class="comment">//表示Map</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date birthDay;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; text; <span class="comment">//数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>properties表示法</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person.name</span>=<span class="string">张三</span></span><br><span class="line"><span class="attr">person.age</span>=<span class="string">18</span></span><br><span class="line"><span class="attr">person.birthDay</span>=<span class="string">2010/10/12 12:12:12</span></span><br><span class="line"><span class="attr">person.like</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">person.child.name</span>=<span class="string">李四</span></span><br><span class="line"><span class="attr">person.child.age</span>=<span class="string">12</span></span><br><span class="line"><span class="attr">person.child.birthDay</span>=<span class="string">2018/10/12</span></span><br><span class="line"><span class="attr">person.child.text[0]</span>=<span class="string">abc</span></span><br><span class="line"><span class="attr">person.child.text[1]</span>=<span class="string">def</span></span><br><span class="line"><span class="attr">person.dogs[0].name</span>=<span class="string">小黑</span></span><br><span class="line"><span class="attr">person.dogs[0].age</span>=<span class="string">3</span></span><br><span class="line"><span class="attr">person.dogs[1].name</span>=<span class="string">小白</span></span><br><span class="line"><span class="attr">person.dogs[1].age</span>=<span class="string">2</span></span><br><span class="line"><span class="attr">person.cats.c1.name</span>=<span class="string">小蓝</span></span><br><span class="line"><span class="attr">person.cats.c1.age</span>=<span class="string">3</span></span><br><span class="line"><span class="attr">person.cats.c2.name</span>=<span class="string">小灰</span></span><br><span class="line"><span class="attr">person.cats.c2.age</span>=<span class="string">2</span></span><br></pre></td></tr></table></figure><p>yaml表示法</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">张三</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">birthDay:</span> <span class="number">2010</span><span class="string">/10/10</span> <span class="number">12</span><span class="string">:12:12</span></span><br><span class="line">  <span class="attr">like:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">child:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">李四</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">birthDay:</span> <span class="number">2018</span><span class="string">/10/10</span></span><br><span class="line">    <span class="attr">text:</span> [<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>]</span><br><span class="line">  <span class="attr">dogs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">小黑</span></span><br><span class="line">      <span class="attr">age:</span> <span class="number">3</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">小白</span></span><br><span class="line">      <span class="attr">age:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">cats:</span></span><br><span class="line">    <span class="attr">c1:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">小蓝</span></span><br><span class="line">      <span class="attr">age:</span> <span class="number">3</span></span><br><span class="line">    <span class="attr">c2:</span> &#123;<span class="attr">name:</span> <span class="string">小绿</span>,<span class="attr">age:</span> <span class="number">2</span>&#125; <span class="comment">#对象也可用&#123;&#125;表示</span></span><br></pre></td></tr></table></figure><h3 id="3-细节"><a href="#3-细节" class="headerlink" title="3. 细节"></a>3. 细节</h3><ul><li>birthDay 推荐写为 birth-day</li><li><p><strong>文本</strong>：</p></li><li><ul><li><strong>单引号</strong>不会转义【\n 则为普通字符串显示】</li><li><strong>双引号</strong>会转义【\n会显示为<strong>换行符</strong>】</li></ul></li><li><p><strong>大文本</strong></p></li><li><ul><li><code>|</code>开头，大文本写在下层，<strong>保留文本格式</strong>，<strong>换行符正确显示</strong></li><li><code>&gt;</code>开头，大文本写在下层，折叠换行符</li></ul></li><li><p><strong>多文档合并</strong></p></li><li><ul><li>使用<code>---</code>可以把多个yaml文档合并在一个文档中，每个文档区依然认为内容独立</li></ul></li></ul><h3 id="4-小技巧：lombok"><a href="#4-小技巧：lombok" class="headerlink" title="4. 小技巧：lombok"></a>4. 小技巧：lombok</h3><p>简化JavaBean 开发。自动生成构造器、getter/setter、自动生成Builder模式等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>使用<code>@Data</code>等注解</p><h2 id="3-日志配置"><a href="#3-日志配置" class="headerlink" title="3. 日志配置"></a>3. 日志配置</h2><p>规范：项目开发不要编写<code>System.out.println()</code>，应该用<strong>日志</strong>记录信息</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1680232037132-d2fa8085-3847-46f2-ac62-14a6188492aa.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_29%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" alt="img"></p><p><strong>感兴趣日志框架关系与起源可参考</strong>：<a href="https://www.bilibili.com/video/BV1gW411W76m">https://www.bilibili.com/video/BV1gW411W76m</a> 视频 21~27集</p><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.  简介"></a>1.  简介</h3><ol><li><p>Spring使用commons-logging作为内部日志，但底层日志实现是开放的。可对接其他日志框架。</p></li><li><ol><li>spring5及以后 commons-logging被spring直接自己写了。</li></ol></li><li><p>支持 jul，log4j2,logback。SpringBoot 提供了默认的控制台输出配置，也可以配置输出为文件。</p></li><li>logback是默认使用的。</li><li>虽然<strong>日志框架很多</strong>，但是我们不用担心，使用 SpringBoot 的<strong>默认配置就能工作的很好</strong>。</li></ol><p><strong>SpringBoot怎么把日志默认配置好的</strong></p><p>1、每个<code>starter</code>场景，都会导入一个核心场景<code>spring-boot-starter</code></p><p>2、核心场景引入了日志的所用功能<code>spring-boot-starter-logging</code></p><p>3、默认使用了<code>logback + slf4j</code> 组合作为默认底层日志</p><p>4、<code>日志是系统一启动就要用</code>，<code>xxxAutoConfiguration</code>是系统启动好了以后放好的组件，后来用的。</p><p>5、日志是利用<strong>监听器机制</strong>配置好的。<code>ApplicationListener</code>。</p><p>6、日志所有的配置都可以通过修改配置文件实现。以<code>logging</code>开始的所有配置。</p><h3 id="2-日志格式"><a href="#2-日志格式" class="headerlink" title="2. 日志格式"></a>2. 日志格式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2023-03-31T13:56:17.511+08:00  INFO 4944 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]</span><br><span class="line">2023-03-31T13:56:17.511+08:00  INFO 4944 --- [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.7]</span><br></pre></td></tr></table></figure><p>默认输出格式：</p><ul><li>时间和日期：毫秒级精度</li><li>日志级别：ERROR, WARN, INFO, DEBUG, or TRACE.</li><li>进程 ID</li><li>—-： 消息分割符</li><li>线程名： 使用[]包含</li><li>Logger 名： 通常是产生日志的<strong>类名</strong></li><li>消息： 日志记录的内容</li></ul><p>注意： logback 没有FATAL级别，对应的是ERROR</p><p>默认值：参照：<code>spring-boot</code>包<code>additional-spring-configuration-metadata.json</code>文件</p><p>默认输出格式值：<code>%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;</code></p><p>可修改为：<code>&#39;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %-5level [%thread] %logger&#123;15&#125; ===&gt; %msg%n&#39;</code></p><h3 id="3-记录日志"><a href="#3-记录日志" class="headerlink" title="3. 记录日志"></a>3. 记录日志</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">或者使用Lombok的<span class="meta">@Slf4j</span>注解</span><br></pre></td></tr></table></figure><h3 id="4-日志级别"><a href="#4-日志级别" class="headerlink" title="4. 日志级别"></a>4. 日志级别</h3><ul><li><p>由低到高：<code>ALL,TRACE, DEBUG, INFO, WARN, ERROR,FATAL,OFF</code>；</p></li><li><ul><li><strong>只会打印指定级别及以上级别的日志</strong></li><li>ALL：打印所有日志</li><li>TRACE：追踪框架详细流程日志，一般不使用</li><li>DEBUG：开发调试细节日志</li><li>INFO：关键、感兴趣信息日志</li><li>WARN：警告但不是错误的信息日志，比如：版本过时</li><li>ERROR：业务错误日志，比如出现各种异常</li><li>FATAL：致命错误日志，比如jvm系统崩溃</li><li>OFF：关闭所有日志记录</li></ul></li><li><p>不指定级别的所有类，都使用root指定的级别作为默认级别</p></li><li>SpringBoot日志<strong>默认级别是</strong> <strong>INFO</strong></li></ul><ol><li>在application.properties/yaml中配置logging.level.<logger-name>=<level>指定日志级别</li><li>level可取值范围：<code>TRACE, DEBUG, INFO, WARN, ERROR, FATAL, or OFF</code>，定义在 <code>LogLevel</code>类中</li><li>root 的logger-name叫root，可以配置logging.level.root=warn，代表所有未指定日志级别都使用 root 的 warn 级别</li></ol><h3 id="5-日志分组"><a href="#5-日志分组" class="headerlink" title="5. 日志分组"></a>5. 日志分组</h3><p>比较有用的技巧是：</p><p>将相关的logger分组在一起，统一配置。SpringBoot 也支持。比如：Tomcat 相关的日志统一设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logging.group.tomcat=org.apache.catalina,org.apache.coyote,org.apache.tomcat</span><br><span class="line">logging.level.tomcat=trace</span><br></pre></td></tr></table></figure><p>SpringBoot 预定义两个组</p><div class="table-container"><table><thead><tr><th>Name</th><th>Loggers</th></tr></thead><tbody><tr><td>web</td><td>org.springframework.core.codec, org.springframework.http, org.springframework.web, org.springframework.boot.actuate.endpoint.web, org.springframework.boot.web.servlet.ServletContextInitializerBeans</td></tr><tr><td>sql</td><td>org.springframework.jdbc.core, org.hibernate.SQL, org.jooq.tools.LoggerListener</td></tr></tbody></table></div><h3 id="6-文件输出"><a href="#6-文件输出" class="headerlink" title="6. 文件输出"></a>6. 文件输出</h3><p>SpringBoot 默认只把日志写在控制台，如果想额外记录到文件，可以在application.properties中添加logging.file.name or logging.file.path配置项。</p><div class="table-container"><table><thead><tr><th>logging.file.name</th><th>logging.file.path</th><th>示例</th><th>效果</th></tr></thead><tbody><tr><td>未指定</td><td>未指定</td><td></td><td>仅控制台输出</td></tr><tr><td><strong>指定</strong></td><td>未指定</td><td>my.log</td><td>写入指定文件。可以加路径</td></tr><tr><td>未指定</td><td><strong>指定</strong></td><td>/var/log</td><td>写入指定目录，文件名为spring.log</td></tr><tr><td><strong>指定</strong></td><td><strong>指定</strong></td><td></td><td>以logging.file.name为准</td></tr></tbody></table></div><h3 id="7-文件归档与滚动切割"><a href="#7-文件归档与滚动切割" class="headerlink" title="7. 文件归档与滚动切割"></a>7. 文件归档与滚动切割</h3><p>归档：每天的日志单独存到一个文档中。</p><p>切割：每个文件10MB，超过大小切割成另外一个文件。</p><ol><li>每天的日志应该独立分割出来存档。如果使用logback（SpringBoot 默认整合），可以通过application.properties/yaml文件指定日志滚动规则。</li><li>如果是其他日志系统，需要自行配置（添加log4j2.xml或log4j2-spring.xml）</li><li>支持的滚动规则设置如下</li></ol><div class="table-container"><table><thead><tr><th>配置项</th><th>描述</th></tr></thead><tbody><tr><td>logging.logback.rollingpolicy.file-name-pattern</td><td>日志存档的文件名格式（默认值：${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz）</td></tr><tr><td>logging.logback.rollingpolicy.clean-history-on-start</td><td>应用启动时是否清除以前存档（默认值：false）</td></tr><tr><td>logging.logback.rollingpolicy.max-file-size</td><td>存档前，每个日志文件的最大大小（默认值：10MB）</td></tr><tr><td>logging.logback.rollingpolicy.total-size-cap</td><td>日志文件被删除之前，可以容纳的最大大小（默认值：0B）。设置1GB则磁盘存储超过 1GB 日志后就会删除旧日志文件</td></tr><tr><td>logging.logback.rollingpolicy.max-history</td><td>日志文件保存的最大天数(默认值：7).</td></tr></tbody></table></div><h3 id="8-自定义配置"><a href="#8-自定义配置" class="headerlink" title="8. 自定义配置"></a>8. 自定义配置</h3><p>通常我们配置 application.properties 就够了。当然也可以自定义。比如：</p><div class="table-container"><table><thead><tr><th>日志系统</th><th>自定义</th></tr></thead><tbody><tr><td>Logback</td><td>logback-spring.xml, logback-spring.groovy, logback.xml, or logback.groovy</td></tr><tr><td>Log4j2</td><td>log4j2-spring.xml or log4j2.xml</td></tr><tr><td>JDK (Java Util Logging)</td><td>logging.properties</td></tr></tbody></table></div><p>如果可能，我们建议您在日志配置中使用<code>-spring</code> 变量（例如，<code>logback-spring.xml</code> 而不是 <code>logback.xml</code>）。如果您使用标准配置文件，spring 无法完全控制日志初始化。</p><p>最佳实战：自己要写配置，配置文件名加上 <code>xx-spring.xml</code></p><h3 id="9-切换日志组合"><a href="#9-切换日志组合" class="headerlink" title="9. 切换日志组合"></a>9. 切换日志组合</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>log4j2支持yaml和json格式的配置文件</p><div class="table-container"><table><thead><tr><th>格式</th><th>依赖</th><th>文件名</th></tr></thead><tbody><tr><td>YAML</td><td>com.fasterxml.jackson.core:jackson-databind + com.fasterxml.jackson.dataformat:jackson-dataformat-yaml</td><td>log4j2.yaml + log4j2.yml</td></tr><tr><td>JSON</td><td>com.fasterxml.jackson.core:jackson-databind</td><td>log4j2.json + log4j2.jsn</td></tr></tbody></table></div><h3 id="10-最佳实战"><a href="#10-最佳实战" class="headerlink" title="10. 最佳实战"></a>10. 最佳实战</h3><ol><li>导入任何第三方框架，先排除它的日志包，因为Boot底层控制好了日志</li><li>修改 <code>application.properties</code> 配置文件，就可以调整日志的所有行为。如果不够，可以编写日志框架自己的配置文件放在类路径下就行，比如<code>logback-spring.xml</code>，<code>log4j2-spring.xml</code></li><li>如需对接<strong>专业日志系统</strong>，也只需要把 logback 记录的<strong>日志</strong>灌倒 <strong>kafka</strong>之类的中间件，这和SpringBoot没关系，都是日志框架自己的配置，<strong>修改配置文件即可</strong></li><li><strong>业务中使用slf4j-api记录日志。不要再 sout 了</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot3 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- GitCalendar容器 --><div id="gitZone"></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>照片</title>
      <link href="/Gallery/index.html"/>
      <url>/Gallery/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>:root {  --trans-light: rgba(255, 255, 255, 0.8);  --trans-dark: rgba(25, 25, 25, 0.8);  --border-style: 1px solid rgb(169, 169, 169);  --backdrop-filter: blur(5px) saturate(150%);}/* 页脚与头图透明 */#footer {    background: transparent !important;  }  #page-header {    background: transparent !important;  }    /* 白天模式遮罩透明 */  #footer::before {    background: transparent !important;  }  #page-header::before {    background: transparent !important;  }    /* 夜间模式遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }  /* 翻页按钮居中 */#pagination {  width: 100%;  margin: auto;}/* 一级菜单居中 */#nav .menus_items {  position: absolute !important;  width: fit-content !important;  left: 50% !important;  transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {  display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(5) .menus_item_child {  left: -70px;}/* 霓虹灯组件 *//* 日间模式不生效 */[data-theme="light"] #site-name,[data-theme="light"] #site-title,[data-theme="light"] #site-subtitle,[data-theme="light"] #post-info {  animation: none;}/* 夜间模式生效 */[data-theme="dark"] #site-name,[data-theme="dark"] #site-title {  animation: light_15px 10s linear infinite;}[data-theme="dark"] #site-subtitle {  animation: light_10px 10s linear infinite;}[data-theme="dark"] #post-info {  animation: light_5px 10s linear infinite;}/* 关键帧描述 */@keyframes light_15px {  0% {    text-shadow: #5636ed 0 0 15px;  }  12.5% {    text-shadow: #11ee5e 0 0 15px;  }  25% {    text-shadow: #f14747 0 0 15px;  }  37.5% {    text-shadow: #f1a247 0 0 15px;  }  50% {    text-shadow: #f1ee47 0 0 15px;  }  50% {    text-shadow: #b347f1 0 0 15px;  }  62.5% {    text-shadow: #002afa 0 0 15px;  }  75% {    text-shadow: #ed709b 0 0 15px;  }  87.5% {    text-shadow: #39c5bb 0 0 15px;  }  100% {    text-shadow: #5636ed 0 0 15px;  }}@keyframes light_10px {  0% {    text-shadow: #5636ed 0 0 10px;  }  12.5% {    text-shadow: #11ee5e 0 0 10px;  }  25% {    text-shadow: #f14747 0 0 10px;  }  37.5% {    text-shadow: #f1a247 0 0 10px;  }  50% {    text-shadow: #f1ee47 0 0 10px;  }  50% {    text-shadow: #b347f1 0 0 10px;  }  62.5% {    text-shadow: #002afa 0 0 10px;  }  75% {    text-shadow: #ed709b 0 0 10px;  }  87.5% {    text-shadow: #39c5bb 0 0 10px;  }  100% {    text-shadow: #5636ed 0 0 10px;  }}@keyframes light_5px {  0% {    text-shadow: #5636ed 0 0 5px;  }  12.5% {    text-shadow: #11ee5e 0 0 5px;  }  25% {    text-shadow: #f14747 0 0 5px;  }  37.5% {    text-shadow: #f1a247 0 0 15px;  }  50% {    text-shadow: #f1ee47 0 0 5px;  }  50% {    text-shadow: #b347f1 0 0 5px;  }  62.5% {    text-shadow: #002afa 0 0 5px;  }  75% {    text-shadow: #ed709b 0 0 5px;  }  87.5% {    text-shadow: #39c5bb 0 0 5px;  }  100% {    text-shadow: #5636ed 0 0 5px;  }}/* 自定义渐变个人信息卡片 */#aside-content > .card-widget.card-info {  background: linear-gradient(    -45deg,    #e8d8b9,    #eccec5,    #a3e9eb,    #bdbdf0,    #eec1ea  );  box-shadow: 0 0 5px rgb(66, 68, 68);  position: relative;  background-size: 400% 400%;  -webkit-animation: Gradient 10s ease infinite;  -moz-animation: Gradient 10s ease infinite;  animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@-moz-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content > .card-widget.card-info {  background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content > .card-widget.card-info > #card-info-btn {  background-color: #3eb8be;  border-radius: 8px;}/* 页面样式调节 *//* 首页文章卡片 */#recent-posts > .recent-post-item {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 25px;  border: var(--border-style);}/* 首页侧栏卡片 */#aside-content .card-widget {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 18px;  border: var(--border-style);}/* 文章页、归档页、普通页面 */div#post,div#page,div#archive {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border: var(--border-style);  border-radius: 20px;}/* 导航栏 */#page-header.nav-fixed #nav {  background: rgba(255, 255, 255, 0.75);  backdrop-filter: var(--backdrop-filter);}[data-theme="dark"] #page-header.nav-fixed #nav {  background: rgba(0, 0, 0, 0.7) !important;}/* 夜间模式遮罩 */[data-theme="dark"] #recent-posts > .recent-post-item,[data-theme="dark"] #aside-content .card-widget,[data-theme="dark"] div#post,[data-theme="dark"] div#archive,[data-theme="dark"] div#page {  background: var(--trans-dark);}/* 夜间模式页脚页头遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}/* 阅读模式 */.read-mode #aside-content .card-widget {  background: rgba(158, 204, 171, 0.5) !important;}.read-mode div#post {  background: rgba(158, 204, 171, 0.5) !important;}/* 夜间模式下的阅读模式 */[data-theme="dark"] .read-mode #aside-content .card-widget {  background: rgba(25, 25, 25, 0.9) !important;  color: #ffffff;}[data-theme="dark"] .read-mode div#post {  background: rgba(25, 25, 25, 0.9) !important;  color: #ffffff;}/* 自定义图标样式 */svg.icon {  width: 1.28em;  height: 1.28em;  vertical-align: -0.15em;  fill: currentColor;  overflow: hidden;}/* 自定义社交卡样式 */svg.social_icon {  width: 1.20em;  height: 1.20em;  vertical-align: -0.15em;  fill: currentColor;  overflow: hidden;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/universe.css"/>
      <url>/css/universe.css</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>/* 背景宇宙星光  */#universe{    display: block;    position: fixed;    margin: 0;    padding: 0;    border: 0;    outline: 0;    left: 0;    top: 0;    width: 100%;    height: 100%;    pointer-events: none;    /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */    z-index: -1;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>留言板</title>
      <link href="/comments/index.html"/>
      <url>/comments/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
    </entry>
    
    
  
</search>
